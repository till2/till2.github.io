---
layout: post
title:  "Aspirilo"
author: "Till Zemann"
date:   2023-01-13 14:31:41 +0200
categories: jekyll update
comments: true
back_to_top_button: true
math: true
positive_reward: true
reward: 2
tags: [uni, asp]
thumbnail: "/images/aspirilo/thumb.png"
---

<!-- thumbnail.png -->


<div class="img-block" style="width: 500px;">
    <img src="/images/aspirilo/thumb.png"/>
</div>

<!--
<em style="float:right">First draft: 2023-01-07</em><br>
-->

<!--
### Contents
* TOC
{:toc}
-->


### Visualizer Installation

Install the [visualizer](https://asprilo.github.io/visualizer/) via:
```bash
conda install asprilo-visualizer -c potassco -c potassco/label/dev.
```

Then you can simply run it using viz:

```bash
viz -t <instance.lp>
```

Or save a plan as a file using these steps:

1. Solve the reified test_instance.lp with our meta-telingo
2. Only capture the `occurs`-atoms using the regular expression `occurs\(.*\)`
3. Pipe the `occurs`-atoms in a `test_plan.lp` file using the `tee` command that pipes them into the file and prints the atoms
4. Run the viz using the `test_instance.lp` and `test_plan.lp` files

This command will first use grep to search for all occurrences of the regular expression "occurs(.*)" in the file "input_file.txt" as before. The output of grep command is piped into sed command, which will use the s/$/./ command to replace the end of line(/$) with a period (.). The sed command will add a period (.) at the end of each atom. The output of the sed command is then piped into the tee command, which writes the output to both the terminal and the specified file "test_plan.lp".

```bash
clingo encoding.lp test_instance.lp --output=reify | clingo - meta-telingo.lp output-meta-telingo.lp -c horizon=9 | grep -o "occurs\(.*\)" | sed 's/ /\./g' | tee test_plan.lp; echo . >> test_plan.lp

viz -l test_instance.lp test_plan.lp
```


### Introduction

Go to:
```bash
/home/till/Desktop/GitHub/telingo-wise22-23-themetaprogrammers/aspirilo-meta-telingo
```

To test if everything works, let's try to run it __without__ using meta-telingo:

```bash
clingo encoding.lp test_instance.lp -c horizon=15 1
```

<div class="output">
clingo version 5.4.1 <br>
Reading from encoding.lp ... <br>
Solving... <br>
Answer: 1 <br>
init(object(order,1),value(pickingStation,1)) init(object(order,2),value(pickingStation,1)) init(object(highway,1),value(at,(1,1))) init(object(highway,2),value(at,(2,1))) init(object(highway,3),value(at,(3,1))) init(object(highway,4),value(at,(4,1))) init(object(highway,5),value(at,(5,1))) init(object(highway,7),value(at,(7,1))) init(object(highway,8),value(at,(8,1))) init(object(highway,9),value(at,(9,1))) init(object(highway,10),value(at,(10,1))) init(object(highway,11),value(at,(11,1))) init(object(highway,12),value(at,(1,2))) init(object(highway,13),value(at,(2,2))) init(object(highway,14),value(at,(3,2))) init(object(highway,15),value(at,(4,2))) init(object(highway,16),value(at,(5,2))) init(object(highway,17),value(at,(6,2))) init(object(highway,18),value(at,(7,2))) init(object(highway,19),value(at,(8,2))) init(object(highway,20),value(at,(9,2))) init(object(highway,21),value(at,(10,2))) init(object(highway,22),value(at,(11,2))) init(object(highway,23),value(at,(1,3))) init(object(highway,28),value(at,(6,3))) init(object(highway,33),value(at,(11,3))) init(object(highway,34),value(at,(1,4))) init(object(highway,39),value(at,(6,4))) init(object(highway,44),value(at,(11,4))) init(object(highway,45),value(at,(1,5))) init(object(highway,46),value(at,(2,5))) init(object(highway,47),value(at,(3,5))) init(object(highway,48),value(at,(4,5))) init(object(highway,49),value(at,(5,5))) init(object(highway,50),value(at,(6,5))) init(object(highway,51),value(at,(7,5))) init(object(highway,52),value(at,(8,5))) init(object(highway,53),value(at,(9,5))) init(object(highway,54),value(at,(10,5))) init(object(highway,55),value(at,(11,5))) init(object(highway,58),value(at,(3,6))) init(object(highway,59),value(at,(4,6))) init(object(highway,60),value(at,(5,6))) init(object(highway,61),value(at,(6,6))) init(object(highway,62),value(at,(7,6))) init(object(highway,63),value(at,(8,6))) init(object(highway,64),value(at,(9,6))) init(object(highway,65),value(at,(10,6))) init(object(highway,66),value(at,(11,6))) init(object(node,1),value(at,(1,1))) init(object(node,2),value(at,(2,1))) init(object(node,3),value(at,(3,1))) init(object(node,4),value(at,(4,1))) init(object(node,5),value(at,(5,1))) init(object(node,6),value(at,(6,1))) init(object(node,7),value(at,(7,1))) init(object(node,8),value(at,(8,1))) init(object(node,9),value(at,(9,1))) init(object(node,10),value(at,(10,1))) init(object(node,11),value(at,(11,1))) init(object(node,12),value(at,(1,2))) init(object(node,13),value(at,(2,2))) init(object(node,14),value(at,(3,2))) init(object(node,15),value(at,(4,2))) init(object(node,16),value(at,(5,2))) init(object(node,17),value(at,(6,2))) init(object(node,18),value(at,(7,2))) init(object(node,19),value(at,(8,2))) init(object(node,20),value(at,(9,2))) init(object(node,21),value(at,(10,2))) init(object(node,22),value(at,(11,2))) init(object(node,23),value(at,(1,3))) init(object(node,24),value(at,(2,3))) init(object(node,25),value(at,(3,3))) init(object(node,26),value(at,(4,3))) init(object(node,27),value(at,(5,3))) init(object(node,28),value(at,(6,3))) init(object(node,29),value(at,(7,3))) init(object(node,30),value(at,(8,3))) init(object(node,31),value(at,(9,3))) init(object(node,32),value(at,(10,3))) init(object(node,33),value(at,(11,3))) init(object(node,34),value(at,(1,4))) init(object(node,35),value(at,(2,4))) init(object(node,36),value(at,(3,4))) init(object(node,37),value(at,(4,4))) init(object(node,38),value(at,(5,4))) init(object(node,39),value(at,(6,4))) init(object(node,40),value(at,(7,4))) init(object(node,41),value(at,(8,4))) init(object(node,42),value(at,(9,4))) init(object(node,43),value(at,(10,4))) init(object(node,44),value(at,(11,4))) init(object(node,45),value(at,(1,5))) init(object(node,46),value(at,(2,5))) init(object(node,47),value(at,(3,5))) init(object(node,48),value(at,(4,5))) init(object(node,49),value(at,(5,5))) init(object(node,50),value(at,(6,5))) init(object(node,51),value(at,(7,5))) init(object(node,52),value(at,(8,5))) init(object(node,53),value(at,(9,5))) init(object(node,54),value(at,(10,5))) init(object(node,55),value(at,(11,5))) init(object(node,56),value(at,(1,6))) init(object(node,57),value(at,(2,6))) init(object(node,58),value(at,(3,6))) init(object(node,59),value(at,(4,6))) init(object(node,60),value(at,(5,6))) init(object(node,61),value(at,(6,6))) init(object(node,62),value(at,(7,6))) init(object(node,63),value(at,(8,6))) init(object(node,64),value(at,(9,6))) init(object(node,65),value(at,(10,6))) init(object(node,66),value(at,(11,6))) init(object(order,1),value(line,(14,1))) init(object(order,2),value(line,(15,1))) init(object(pickingStation,1),value(at,(6,1))) init(object(product,1),value(on,(2,1))) init(object(product,2),value(on,(6,1))) init(object(product,3),value(on,(10,1))) init(object(product,4),value(on,(1,1))) init(object(product,5),value(on,(3,1))) init(object(product,6),value(on,(4,1))) init(object(product,7),value(on,(5,1))) init(object(product,8),value(on,(7,1))) init(object(product,9),value(on,(8,1))) init(object(product,10),value(on,(9,1))) init(object(product,11),value(on,(11,1))) init(object(product,12),value(on,(12,1))) init(object(product,13),value(on,(13,1))) init(object(product,14),value(on,(14,1))) init(object(product,15),value(on,(15,1))) init(object(product,16),value(on,(16,1))) init(object(robot,1),value(at,(1,6))) init(object(robot,2),value(at,(2,6))) init(object(shelf,1),value(at,(8,3))) init(object(shelf,2),value(at,(5,3))) init(object(shelf,3),value(at,(3,3))) init(object(shelf,4),value(at,(9,3))) init(object(shelf,5),value(at,(7,3))) init(object(shelf,6),value(at,(4,3))) init(object(shelf,7),value(at,(10,4))) init(object(shelf,8),value(at,(8,4))) init(object(shelf,9),value(at,(7,4))) init(object(shelf,10),value(at,(4,4))) init(object(shelf,11),value(at,(2,3))) init(object(shelf,12),value(at,(2,4))) init(object(shelf,13),value(at,(5,4))) init(object(shelf,14),value(at,(9,4))) init(object(shelf,15),value(at,(3,4))) init(object(shelf,16),value(at,(10,3))) occurs(object(robot,1),action(move,(1,0)),1) occurs(object(robot,1),action(move,(1,0)),2) occurs(object(robot,1),action(move,(1,0)),3) occurs(object(robot,1),action(move,(0,-1)),4) occurs(object(robot,1),action(move,(0,-1)),5) occurs(object(robot,1),action(move,(1,0)),6) occurs(object(robot,1),action(move,(1,0)),7) occurs(object(robot,1),action(move,(1,0)),8) occurs(object(robot,1),action(move,(1,0)),9) occurs(object(robot,1),action(move,(1,0)),10) occurs(object(robot,2),action(move,(0,-1)),1) occurs(object(robot,2),action(move,(0,-1)),2) occurs(object(robot,2),action(move,(1,0)),3) <br>
SATISFIABLE <br>
<br>
Models       : 1+ <br>
Calls        : 1 <br>
Time         : 0.028s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s) <br>
CPU Time     : 0.028s <br>
</div>

Great, we have an answer! I believe that only the `occurs(object(robot,1),action(move,(1,0)),2)` atoms are part of the solution. This example atom says that robot1 moved 1 cell up in timestep 2. The rest of the atoms are all part of the initialization of the instance.

Now we can try to break everything by converting it to meta-telingo :D


To solve an instance with our `meta-telingo.lp` program, you need to first reify `encoding.lp` (which includes `action-M.lp`, a goal-test `goal-M.lp` and an output conversion file `output-M.lp`) and the instance, in our case `test_instance.lp`. We also automatically include `input.lp` in the `action-M.lp` file. Then you pipe the reified facts into `meta-telingo.lp` to solve it using clingo, in this case using `horizon=15` and showing the first model by setting the number of models parameter to `1`.
```bash
clingo encoding.lp test_instance.lp --output=reify | clingo - meta-telingo.lp -c horizon=15 1
```

_For the KRR project, we will restrict ourselves to the movement only (`M`) domain._


### Action-M.lp encoding

- rewrite with `prev()` operators instead of `T-1`
- add `#external` commands with all atoms that are possible for this atom included on the right hand side to avoid unsafe atmoms, e.g. `#external move(R,C) :- robot(R), vertex(C)` (maybe instead of `:-` only write `:`, try both and test which one works. Also look in the files from the beginning of the semester to see how we did it there.)

#### Include the input encoding

For the `input.lp` encoding, we'll have to change the path since it's in the same directory: 
```c
#include "./input.lp".
```

#### Position/3

The robot `R` is at cell `C`, which is a tuple with the coordinates (X,Y), at time step `T`. 

```c
position(R,C,T) :- move(R,D,T), position(R,C',T-1),     nextto(C',D,C).
                :- move(R,D,T), position(R,C ,T-1), not nextto(C ,D,_).
```

We'll now modify all of the code in `action.lp` to use `prev(atom(T))` instead of `atom(T-1)`.
For the previous code block, this is the result:

```c
position(R,C,T) :- move(R,D,T), prev(position(R,C',T)),     nextto(C',D,C).
                :- move(R,D,T), prev(position(R,C ,T)), not nextto(C ,D,_).
```

#### Externals

Now that we have included some meta-telingo _prev_ operators, we'll have to tell clingo to not delete them in preprocessing by using `#external`.

```c
%*
externals
*%
aux_cell(C) :- nextto(C,_,_).
aux_cell(C) :- position(_,C,_).

#external prev(position(R,C,T)) : robot(R), aux_cell(C), time(T).
#external initially.
#external finally.
#external horizon.
```

Here is the program with all the discussed changes so far:
```lp
#include "./input.lp".

#const horizon=15.
time(1..horizon).

direction((X,Y)) :- X=-1..1, Y=-1..1, |X+Y|=1.
nextto((X,Y),(X',Y'),(X+X',Y+Y')) :- position((X,Y)), direction((X',Y')), position((X+X',Y+Y')).

{ move(R,D,T) : direction(D) } 1 :- isRobot(R), time(T).

% - move/3 ----------------------------------------------------------------------
position(R,C,T) :- move(R,D,T), prev(position(R,C',T)),     nextto(C',D,C).
                :- move(R,D,T), prev(position(R,C ,T)), not nextto(C ,D,_).

% - inertia ---------------------------------------------------------------------
position(R,C,T) :- prev(position(R,C,T)), not move(R,_,T), isRobot(R), time(T).

% - edge collision --------------------------------------------------------------
moveto(C',C,T) :- nextto(C',D,C), prev(position(R,C',T)), move(R,D,T).
:- moveto(C',C,T), moveto(C,C',T), C < C'.

% - vertex collision ------------------------------------------------------------
:- { position(R,C,T) : isRobot(R) }  > 1, position(C), time(T).

% - auxiliaries -----------------------------------------------------------------
:- { position(R,C,T) } != 1, isRobot(R), time(T).    % REDUNDANT but PERFORMANT?

%*
externals
*%
aux_cell(C) :- nextto(C,_,_).
aux_cell(C) :- position(_,C,_).

#external prev(position(R,C,T)) : robot(R), aux_cell(C), time(T).
#external initially.
#external finally.
```

Let's try to run it.

```bash
clingo encoding.lp test_instance.lp --output=reify | clingo - meta-telingo.lp -c horizon=15 1
```

<div class="output">
clingo version 5.4.1 <br>
Reading from - ... <br>
Solving... <br>
UNSATISFIABLE <br>
 <br>
Models       : 0 <br>
Calls        : 1 <br>
Time         : 11.617s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s) <br>
CPU Time     : 11.616s <br>
</div>

This should have been satisfiable, so we are not finished yet. Let's try to remove the timestep atoms.


#### Time

Now comes the hardest step: We will have to remove all timesteps `T` from the code since the time is already being handled in `meta-telingo.lp`.


The `goal-M.lp` file before removing the timesteps:

```c
processed(A,R) :- ordered(O,A), shelved(S,A), isRobot(R), position(S,C,0),
                  position(R,C,horizon).
processed(A)   :- processed(A,R).

:- ordered(O,A), not processed(A).
```

The `output-M.lp` file before removing the timesteps:

```c
#show.
#show init/2.

#show occurs(object(robot,R), action(move,D),     T) :    move(robot(R),D,T).
```

The old `input.lp` file before removing timesteps: 

```c
% --------------------------------------------------------------------------------
% REPRESENTATION

robot(R)                     :- init(object(robot,R),          _).
shelf(S)                     :- init(object(shelf,S),          _).
station(P)                   :- init(object(pickingStation,P), _).
product(A)                   :- init(object(product,A),        _).

    isRobot(robot(R)) :- robot(R).
    isShelf(shelf(S)) :- shelf(S).
isStation(station(T)) :- station(T).
isProduct(product(A)) :- product(A).
    isOrder(order(O)) :- order(O).

  order(      O            ) :- init(object(order,O),          _).
ordered(order(O),product(A)) :- init(object(order,O),          value(line,(A,_))).      % IGNORING QUANTITIES
 target(order(O),station(P)) :- init(object(order,O),          value(pickingStation,P)).

shelved(shelf(S),product(A)) :- init(object(product,A),        value(on,(S,_))).        % IGNORING QUANTITIES

position(           (X,Y))   :- init(object(node,_),           value(at,(X,Y))).

position(station(P),(X,Y))   :- init(object(pickingStation,P), value(at,(X,Y))).

position(  robot(R),(X,Y),0) :- init(object(robot,R),          value(at,(X,Y))).
position(  shelf(S),(X,Y),0) :- init(object(shelf,S),          value(at,(X,Y))).

highway(            C    )   :- init(object(highway,_),        value(at,C)).
```

<!-- In-Text Citing -->
<!-- 
You can...
- use bullet points
1. use
2. ordered
3. lists


-- Math --
$\hat{s} = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \mu)^2$ 

-- Images --
<div class="img-block" style="width: 800px;">
    <img src="/images/lofi_art.png"/>
    <span><strong>Fig 1.1.</strong> Agent and Environment interactions</span>
</div>

-- Links --
[(k-fold) Cross-Validation](https://scikit-learn.org/stable/modules/cross_validation.html)

{% highlight python %}
@jit
def f(x)
    print("hi")
# does cool stuff
{% endhighlight %}

-- Highlights --
AAABC `ASDF` __some bold text__

-- Colors --
The <strong style="color: #1E72E7">joint distribution</strong> of $X$ and $Y$ is written as $P(X, Y)$.
The <strong style="color: #ED412D">marginal distribution</strong> on the other hand can be written out as a table.
-->

<!-- uncomment, when i understand more of the algorithms presented (missing DDPG, SAC, TD3, TRPO, PPO, Dyna-Q)
### Rl-Algorithms-Taxonomy in a Venn-Diagram

<div class="img-block" style="width: 700px;">
    <img src="/images/actor-critic/venn-diagram-rl-algos-detailed.png"/>
</div>

-->

### References 
1. [Aspirilo website][aspirilo-website].


<!-- Ressources -->
[aspirilo-website]: https://asprilo.github.io/visualizer/

<!-- Optional Comment Section-->
{% if page.comments %}
<p class="vspace"></p>
<a class="commentlink" role="button" href="/comments/">Post a comment.</a> <!-- role="button"  -->
{% endif %}

<!-- Optional Back to Top Button -->
{% if page.back_to_top_button %}
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  backgroundColor: 'rgb(255, 255, 255, 0.7)', /* 30,144,255, 0.7 */
  textColor: '#4a4946'
})</script>
{% endif %}
